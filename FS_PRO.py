"""
FS_PRO
Full Stack Parallel Rocket Optimizer
Dyllon Preston
"""

import pygmo as pg
import time
import os
import glob

from pygmo import gaco, problem, algorithm, mp_bfe, archipelago, ipopt, island
from Udp import Udp
from rocketpy import Environment

def main():

    post_process = False # Nonrmally should be kept as false
    
    data_output = True # set to true to save data on rockets generated by optimizer

    identical_motors = True
    identical_fins = False

    smart_motor_odia = True # Sets the max motor odia to be the largest value allowed based on the largest diameter
    smart_diameter_bounds = True # Sets the bounds of the rocket diameter to only include the uppere bound diameter. Assumes bigger is better.



    #All Bounds in Inches
    """
        Continuous Bounds
    """
    motor_1_lower_bounds = {
        'MEOP_1': 400,
        'odia_1': 5,
        'dia_1': 0.1,
        'length_1': 60,
    }
    motor_1_upper_bounds = {
        'MEOP_1': 500,
        'odia_1': 12,
        'dia_1': 12,
        'length_1': 80,
    }
    motor_2_lower_bounds = {
        'MEOP_2': 400,
        'odia_2': 5,
        'dia_2': 0.1,
        'length_2': 60,
    }
    motor_2_upper_bounds = {
        'MEOP_2': 500,
        'odia_2': 12,
        'dia_2': 12,
        'length_2': 80,
    }
    finset_1_lower_bounds = {
        'root_1': 12,
        'span_1': 8,  #min odia *1.2
        'tip_1': 3,
        'sweep_1': 10,
    }
    finset_1_upper_bounds = {
        'root_1': 26,
        'span_1': 12, #max odia * 1.5
        'tip_1': 20/3,
        'sweep_1': 20*2/3,
    }
    finset_2_lower_bounds = {
        'root_2': 12,
        'span_2': 8, #min odia *1.2
        'tip_2': 3,
        'sweep_2': 10,
    }
    finset_2_upper_bounds = {
        'root_2': 26,
        'span_2': 12,
        'tip_2': 20/3,
        'sweep_2': 20*2/3,
    }
    rocket_lower_bounds = {
        'ignitionDelay': 5, #Reducing too low can cause errors
    }
    rocket_upper_bounds = {
        'ignitionDelay': 40, #mannually select ignition delay with wind
    }

    """
    Integer constraints
    """
    motor_1_lower_bounds_int = {
        'number_1': 3,
    }
    motor_1_upper_bounds_int = {
        'number_1': 12
    }
    motor_2_lower_bounds_int = {
        'number_2': 3,
    }
    motor_2_upper_bounds_int = {
        'number_2': 12,
    }
    chutes_lower_bounds_int = {
        'diachute_1': 2,
        'diachute_2': 2,
        'diachute_3': 2,
    }
    chutes_upper_bounds_int = {
        'diachute_1': 7,
        'diachute_2': 7,
        'diachute_3': 7,
    }
    rocket_lower_bounds_int = {
        'diameter': 0,
    }
    rocket_upper_bounds_int = {
        'diameter': 2,
    }
    
    # [1, 1.135, 1.25, 1.5]

    viable_diams = [6, 7.76, 8.75, 11.67] 
    casing_thickness = [1, 1.135, 1.0, 1.5][int(rocket_upper_bounds_int['diameter'])]

    if smart_diameter_bounds == True and (rocket_upper_bounds_int['diameter'] - rocket_lower_bounds_int['diameter']) > 1:
        rocket_lower_bounds_int['diameter'] = rocket_upper_bounds_int['diameter'] - 1
    if smart_motor_odia == True:
        odia_max = viable_diams[int(rocket_upper_bounds_int['diameter'])] - 0.75
        motor_1_upper_bounds['odia_1'] = odia_max
        motor_2_upper_bounds['odia_2'] = odia_max


    """
    -------------------------------------------------------- Remove CSV Files --------------------------------------------------------
    """

    files = glob.glob("./data output/*.csv")

    for f in files:
        os.remove(f)



    lower_bounds = {}
    upper_bounds = {}

    decision_dict = {}
    decision_dict.update(motor_1_lower_bounds)
    decision_dict.update(motor_2_lower_bounds)
    decision_dict.update(finset_1_lower_bounds)
    decision_dict.update(finset_2_lower_bounds)
    decision_dict.update(rocket_lower_bounds)
    decision_dict.update(motor_1_lower_bounds_int)
    decision_dict.update(motor_2_lower_bounds_int)
    decision_dict.update(chutes_lower_bounds_int)
    decision_dict.update(rocket_lower_bounds_int)




    if identical_motors and identical_fins:
        lower_bounds.update(motor_1_lower_bounds)
        lower_bounds.update(finset_1_lower_bounds)
        lower_bounds.update(rocket_lower_bounds)
        lower_bounds.update(motor_1_lower_bounds_int)
        lower_bounds.update(chutes_lower_bounds_int)
        lower_bounds.update(rocket_lower_bounds_int)

        upper_bounds.update(motor_1_upper_bounds)
        upper_bounds.update(finset_1_upper_bounds)
        upper_bounds.update(rocket_upper_bounds)
        upper_bounds.update(motor_1_upper_bounds_int)
        upper_bounds.update(chutes_upper_bounds_int)
        upper_bounds.update(rocket_upper_bounds_int)

        num_int = len(motor_1_upper_bounds_int.keys())+len(chutes_upper_bounds_int.keys()) + len(rocket_upper_bounds_int.keys())
        num_constraints = 13
    elif identical_motors:
        lower_bounds.update(motor_1_lower_bounds)
        lower_bounds.update(finset_1_lower_bounds)
        lower_bounds.update(finset_2_lower_bounds)
        lower_bounds.update(rocket_lower_bounds)
        lower_bounds.update(motor_1_lower_bounds_int)
        lower_bounds.update(chutes_lower_bounds_int)
        lower_bounds.update(rocket_lower_bounds_int)

        upper_bounds.update(motor_1_upper_bounds)
        upper_bounds.update(finset_1_upper_bounds)
        upper_bounds.update(finset_2_upper_bounds)
        upper_bounds.update(rocket_upper_bounds)
        upper_bounds.update(motor_1_upper_bounds_int)
        upper_bounds.update(chutes_upper_bounds_int)
        upper_bounds.update(rocket_upper_bounds_int)

        num_int = len(motor_1_upper_bounds_int.keys())+len(chutes_upper_bounds_int.keys()) + len(rocket_upper_bounds_int.keys())
        num_constraints = 15
    elif identical_fins:
        lower_bounds.update(motor_1_lower_bounds)
        lower_bounds.update(motor_2_lower_bounds)
        lower_bounds.update(finset_1_lower_bounds)
        lower_bounds.update(rocket_lower_bounds)
        lower_bounds.update(motor_1_lower_bounds_int)
        lower_bounds.update(motor_2_lower_bounds_int)
        lower_bounds.update(chutes_lower_bounds_int)
        lower_bounds.update(rocket_lower_bounds_int)

        upper_bounds.update(motor_1_upper_bounds)
        upper_bounds.update(motor_2_upper_bounds)
        upper_bounds.update(finset_1_upper_bounds)
        upper_bounds.update(rocket_upper_bounds)
        upper_bounds.update(motor_1_upper_bounds_int)
        upper_bounds.update(motor_2_upper_bounds_int)
        upper_bounds.update(chutes_upper_bounds_int)
        upper_bounds.update(rocket_upper_bounds_int)
        
        num_int = 2*len(motor_1_upper_bounds_int.keys())+len(chutes_upper_bounds_int.keys()) + len(rocket_upper_bounds_int.keys())
        num_constraints = 19
    else:
        lower_bounds.update(motor_1_lower_bounds)
        lower_bounds.update(motor_2_lower_bounds)
        lower_bounds.update(finset_1_lower_bounds)
        lower_bounds.update(finset_2_lower_bounds)
        lower_bounds.update(rocket_lower_bounds)
        lower_bounds.update(motor_1_lower_bounds_int)
        lower_bounds.update(motor_2_lower_bounds_int)
        lower_bounds.update(chutes_lower_bounds_int)
        lower_bounds.update(rocket_lower_bounds_int)

        upper_bounds.update(motor_1_upper_bounds)
        upper_bounds.update(motor_2_upper_bounds)
        upper_bounds.update(finset_1_upper_bounds)
        upper_bounds.update(finset_2_upper_bounds)
        upper_bounds.update(rocket_upper_bounds)
        upper_bounds.update(motor_1_upper_bounds_int)
        upper_bounds.update(motor_2_upper_bounds_int)
        upper_bounds.update(chutes_upper_bounds_int)
        upper_bounds.update(rocket_upper_bounds_int)

        num_int = 2*len(motor_1_upper_bounds_int.keys())+len(chutes_upper_bounds_int.keys()) + len(rocket_upper_bounds_int.keys())
        num_constraints = 21





    Env = Environment(
            railLength=7.3152,
            latitude=32.990254,
            longitude=-106.974998,
            elevation=615,
            )

    # unless I put in a catch for stability, this cannot be implemented
    # Env.setAtmosphericModel(type='CustomAtmosphere', wind_u = 10*0.44704)


    """
    -------------------------------------------------------- Initialize Optimizer --------------------------------------------------------
    """


    start = time.time()

    b = mp_bfe()
    uda = gaco(175, 20, 1.0, 1e7, 0.0, 1, 7, 100000, 100000, 0.0, False)
    # uda = ipopt()
    # uda.set_integer_option("max_iter", 2500)

    prob = problem(
        Udp(
            lower_bounds = lower_bounds,
            upper_bounds = upper_bounds,
            decision_dict = decision_dict,
            Env = Env,
            num_int = num_int,
            num_constraints = num_constraints,
            identical_motors = identical_motors,
            identical_fins = identical_fins,
            post_process = post_process, 
            data_output = data_output
            )
        )
    algo = algorithm(uda)

    algo.set_verbosity(1)

    # print("Starting StabilityTest: 100 Pop")
    # pop = pg.population(prob, size=100)
    # print("Stability Test Finished: 100 Pop")
    # breakpoint()

    archi = archipelago(n = 11, algo = algo, prob = prob, b = b, pop_size = 20) #8 islands is fast, 9 also seems pretty good


    archi.evolve()
    archi.wait()

    res_fit = archi.get_champions_f()
    res_dec = archi.get_champions_x()

    # uda_2 = nlopt('cobyla')
    # uda_2.maxeval = 100

    # uda_2 = nlopt('slsqp')
    # uda_2.maxeval = 2
    # uda_2.maxtime = 60

    b_2 = mp_bfe()

    uda_2 = ipopt()
    uda_2.set_integer_option("max_iter", 100)
    # uda_2.set_numeric_option("max_wall_time", 4800)


    algo_2 = algorithm(uda_2)
    # algo_2 = algorithm(mbh(algo_2))
    archi_2 = archipelago(n = 0, algo = algo_2, prob = prob, b = b_2, pop_size = 0)

    fit_ind = [i for i in range(len(res_fit)) if res_fit[i][0] != 0] #find the index of all decision vectors with a nonzero apogee
    res_dec = [res_dec[i] for i in fit_ind] #index all decision vectors with a nonzero apogee
    
    #create an island from each decision vector for local optimization. Functions like multistart
    for x in res_dec:
        pop = pg.population(prob, b = b, size=0)
        pop.push_back(x.tolist())
        isl = island(algo = algo_2, pop = pop)
        archi_2.push_back(isl)
    
    algo_2.set_verbosity(1)

    archi_2.evolve()
    archi_2.wait()

    res_fit = archi_2.get_champions_f()
    res_dec = archi_2.get_champions_x()

    print(res_fit)

    # print("----------------\n")
    # print("Fitness Vectors")
    # df_f = pd.DataFrame(res_fit, columns =['Apogee(km):', 'odia1>dia1:', 'c2:', 'c3:', 'max pressure 1:', 'c5:', 'flux 1:', 'odia2>dia2:', 'c8:', 'c9:', 'max pressure 2:', 'c11:', 'flux 2:', 'c13:', 'c14:', 'stability:', 'motorfit 1:', 'motorfit 2:'])
    # print(df_f)
    # print("Decision Vectors")
    # df_x = pd.DataFrame(res_dec, columns =['A_t_1:', 'odia_1:', 'dia_1:', 'length_1:', 'A_t_2:', 'odia_2:', 'dia_2:', 'length_2:', 'r1:', 'sp1:', 't1', 'sw1:', 'r2:', 'sp2:', 't2:', 'sw2:', 'ig_delay:', 'chute1_B:', 'chute2_S:', 'chute3_NC:', 'diam:', 'n1:', 'n2:'])
    # print(df_x)


    end = time.time()
    print("Elapsed time: ", end - start)
    breakpoint()
    print("FS-Pro Completed")

if __name__ == '__main__':
    main()

"""
Current Problems
- Grain height sometimes go negative (temp fix sets it to zero)
- Sometimes get a negative thrust force (currently setting it to zero as a temp fix)
- GRAIN HEIGHT IS IN INCHES, NOT METERS RIGHT NOW. nevermind, its acstually fine
- Test start up speed with post processing o nand off

- CHECK NOZZLE LENGTH THING IN MOTOR?

- RASAERO WEIGHT VALUES FOR TOTAL ROCKET SHOULDN'T INCLUDE MOTOR, WHICH AFFECTS CGs

Current Questions
- Is throat radius correct?
- What is nozzel radius
- Make sure thrust conversion factor is correct

Comments
- RocketPY can do fin flutter
- RocketPY can do bending moments and shear forces (due to rails)
- RocketPY can do static margin
- Some of these things we can make constraints

Assumptions
- If Burn out time is less than 2 seconds, apogee is 0
- If mass * 30 is geater then max thrust value, apogee is 0
- If max thrust is less than 500, return 0

Notes
- Lord knows I'll need some good fin constraints
- Got a warning about ODE Int doing extra work now with two independent motors
- Change xtol so less processors end with 0 apogee
- Need to include ignition delay as parameter
- Not doing post processing on recoveries, not necesary?

"""